main.py

from fastapi import HTTPException

import uvicorn
from fastapi import FastAPI
from contextlib import asynccontextmanager

from models import create_all_tables
from view import OrderView, UserView
from interface import DataBaseInterface

@asynccontextmanager
async def app_lifespan(app: FastAPI):
    create_all_tables()
    yield

app = FastAPI(
    title="Freelance exchange",
    version="1.0.0",
    lifespan=app_lifespan
)

@app.get("/")
def root():
    return "ok"



@app.post("/neworder")
def create_order(body: OrderView):
    new_order_id = DataBaseInterface.create_order(body)
    return {"order_id": new_order_id}

@app.post("/new_user")
def create_item(body: UserView):
    new_user_id = DataBaseInterface.create_user(body)
    return {"user_id": new_user_id}


@app.get("/order/{_id}")
def get_order_id(_id: int):
    order = DataBaseInterface.get_order_by_id(_id)
    if order:
        return order_to_json(order)
    else:
        raise HTTPException(status_code=404, detail="Заказ не найден")


def order_to_json(order):
    return {
        "id": order.id,
        "executorId": order.executorId,
        "customerId": order.customerId,
        "theme": order.theme,
        "Price": order.Price,
        "URLPhoto": order.URLPhoto
        }


@app.get("/order/{theme}")
def get_order_id(theme: str):
    order1 = DataBaseInterface.get_order_by_theme(theme)
    if order1:
        return order_to_json2(order1)
    else:
        raise HTTPException(status_code=404, detail="Заказ не найден")


def order_to_json2(order):
    return {
        "id": order.id,
        "theme": order.theme
        }


@app.get("/user/{_id}")
def get_user_id(_id: int):
    user = DataBaseInterface.get_user_by_id(_id)
    if user:
        return user_to_json(user)
    else:
        raise HTTPException(status_code=404, detail="Пользователь не найден")


def user_to_json(user):
    return {
        "id": user.id,
        "name": user.name,
        "portfolio": user.portfolio
        }

@app.get("/all/users")
def get_all_users():
    users = DataBaseInterface.get_all_users()
    users_json = [user_to_json(user) for user in users]
    return users_json


@app.get("/all/orders")
def get_all_order():
    orders = DataBaseInterface.get_all_orders()
    orders_json = [order_to_json(order) for order in orders]
    return orders_json


@app.delete("/orderdel/{_id}")
def order_delete(_id: int):
    deleted = DataBaseInterface.delete_order_by_id(_id)
    if deleted:
        print("Заказ успешно удален вместе с его изображениями")
    else:
        print("Заказ с указанным идентификатором не найден")


@app.delete("/userdel/{_id}")
def user_delete(_id: int):
    deleted = DataBaseInterface.delete_user_by_id(_id)
    if deleted:
        print("Пользователь успешно удален")
    else:
        print("Пользователь с указанным идентификатором не найден")


@app.put("/addorderPhoto/{order_id}")
def add_order_Photo(order_id: int, URLPhoto: str):
    if not DataBaseInterface.update_order_URLPhoto(order_id, URLPhoto):
        raise HTTPException(status_code=404, detail="Заказ не найден")
    return {"return": "Ссылка успешно обновлена"}


@app.put("/newaddorderPhoto/{order_id}")
def new_add_order_Photo(order_id: int, URLPhoto: str):
    if not DataBaseInterface.nupdate_order_URLPhoto(order_id, URLPhoto):
        raise HTTPException(status_code=404, detail="Заказ не найден")
    return {"return": "Ссылка успешно обновлена"}


@app.put("/addorderexecutor/{order_id}")
def add_order_executor(order_id: int, executorId: int):
    if not DataBaseInterface.update_order_executor(order_id, executorId):
        raise HTTPException(status_code=404, detail="Заказ не найден")
    return {"return": "Исполнитель успешно обновлён"}


@app.put("/newuserportfolio/{user_id}")
def new_update_user_portfolio(user_id: int, portfolio: str):
    if not DataBaseInterface.new_update_user_portfolio(user_id, portfolio):
        raise HTTPException(status_code=404, detail="Пользователь не найден")
    return {"message": "Портфолио успешно обновлено"}

@app.put("/userportfolio/{user_id}")
def update_user_portfolio(user_id: int, portfolio: str):
    if not DataBaseInterface.update_user_portfolio(user_id, portfolio):
        raise HTTPException(status_code=404, detail="Пользователь не найден")
    return {"message": "Портфолио успешно обновлено"}





if __name__ == "__main__":
    uvicorn.run(app)



interface.py

from sqlalchemy import select, delete
from connector import session_factory
from view import OrderView, UserView
from models import Orders, PictureRequest, User


class DataBaseInterface:

    @classmethod
    def create_order(cls, order: OrderView):
        with session_factory() as session:
            order_db = Orders(
                theme=order.theme,
                Price=order.Price,
                customerId=order.customerId,
                executorId=order.executorId
            )
            session.add(order_db)
            session.flush()
            session.commit()
            _id = order_db.id
            return _id


    @classmethod
    def create_user(cls, user: UserView):
        with session_factory() as session:
            user_db = User(
                name=user.name,
                password=user.password
            )
            session.add(user_db)
            session.flush()
            session.commit()
            _id = user_db.id
            return _id

    @classmethod
    def get_order_by_id(cls, _id: int):
        with session_factory() as session:
            order = select(Orders).where(Orders.id == _id)
            order = session.execute(order)
            order = order.unique().scalars().first()
            return order

    @classmethod
    def get_order_by_theme(cls, theme: str):
        with session_factory() as session:
            order1 = select(Orders).where(Orders.theme == theme)
            order1 = session.execute(order1)
            order1 = order1.unique().scalars().first()
            return order1
    @classmethod
    def get_all_orders(cls):
        with session_factory() as session:
            orders = session.query(Orders).all()
            return orders

    @classmethod
    def get_user_by_id(cls, _id: int):
        with session_factory() as session:
            user = select(User).where(User.id == _id)
            user = session.execute(user)
            user = user.unique().scalars().first()
            return user

    @classmethod
    def get_all_users(cls):
        with session_factory() as session:
            users = session.query(User).all()
            return users


    @classmethod
    def delete_order_by_id(cls, _id: int):
        with session_factory() as session:
            order = delete(Orders).where(Orders.id == _id)
            result = session.execute(order)
            session.commit()
            return result.rowcount > 0

    @classmethod
    def delete_user_by_id(cls, _id: int):
        with session_factory() as session:
            user = delete(User).where(User.id == _id)
            result = session.execute(user)
            session.commit()
            return result.rowcount > 0

    @classmethod
    def nupdate_order_URLPhoto(cls, order_id: int, URLPhoto: str):
        with session_factory() as session:
            order = session.query(Orders).filter(Orders.id == order_id).first()
            if order:
                order.URLPhoto = URLPhoto
                session.commit()
                return True
            return False

    @classmethod
    def update_order_URLPhoto(cls, order_id: int, URLPhoto: str):
        with session_factory() as session:
            order = session.query(Orders).filter(Orders.id == order_id).first()
            if order:
                if order.URLPhoto:
                    order.URLPhoto = f"{order.URLPhoto}, {URLPhoto}"
                else:
                    order.URLPhoto = URLPhoto
                session.commit()
                return True
            return False


    @classmethod
    def update_order_executor(cls, order_id: int, executorId: int):
        with session_factory() as session:
            order = session.query(Orders).filter(Orders.id == order_id).first()
            if order:
                order.executorId = executorId
                session.commit()
                return True
            return False


    @classmethod
    def update_user_portfolio(cls, user_id: int, new_portfolio_data: str):
        with session_factory() as session:
            user = session.query(User).filter(User.id == user_id).first()
            if user:
                if user.portfolio:
                    user.portfolio += ",  " + new_portfolio_data
                else:
                    user.portfolio = new_portfolio_data
                session.commit()
                return True
            return False

    @classmethod
    def new_update_user_portfolio(cls, user_id: int, portfolio: str):
        with session_factory() as session:
            user = session.query(User).filter(User.id == user_id).first()
            if user:
                user.portfolio = portfolio
                session.commit()
                return True
            return False

view.py

from typing import Optional

from pydantic import BaseModel

class UserView(BaseModel):
    id: int
    name: str
    password: str
    portfolio: Optional[str] = None


class PictureRequestView(BaseModel):
    id: int
    order_id: int
    picture_url: str


class OrderView(BaseModel):
    id: int
    theme: str
    customerId: int
    executorId: Optional[int] = None
    Price: float
    URLPhoto: Optional[str] = None



models.py


from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from typing import Annotated
from sqlalchemy import BigInteger, ForeignKey, Column, String

from connector import engine

intpk = Annotated[int, mapped_column(BigInteger, primary_key=True)]



class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = "users"

    id: Mapped[intpk] = mapped_column(primary_key=True)
    name: Mapped[str]
    password: Mapped[str]
    portfolio: Mapped[str] = Column(String)


class Orders(Base):
    __tablename__ = "orders"

    id: Mapped[intpk] = mapped_column(primary_key=True)
    customerId: Mapped[int] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"))
    executorId: Mapped[int]
    theme: Mapped[str] = mapped_column(primary_key=True)
    Price: Mapped[float]
    URLPhoto: Mapped[str] = Column(String)


class PictureRequest(Base):
    __tablename__ = "Picture_Request"

    id: Mapped[intpk] = mapped_column(primary_key=True)
    order_id: Mapped[int] = mapped_column(ForeignKey("orders.id", ondelete="CASCADE"))
    picture: Mapped[str]



def create_all_tables():
    Base.metadata.create_all(bind=engine)

